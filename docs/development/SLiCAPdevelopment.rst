==================
SLiCAP development
==================

.. image:: https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png
    :target: http://creativecommons.org/licenses/by-nc-nd/4.0/
    :width: 88
    :alt: Creative Commons License

SLiCAP is licensed under a `Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License <http://creativecommons.org/licenses/by-nc-nd/4.0/>`_. Based on a work at: `http://www.analog-electronics.eu/slicap/slicap.html <http://www.analog-electronics.eu/slicap/slicap.html>`_


.. admonition:: Notes

   This page presents some design considerations for the current open-source version of SLiCAP and thoughts for future developments.

Considerations
==============

Expansion of models
------------------- 
 
During the checking of a netlist, small-signal models of operational amplifiers and semiconductors are expanded into networks with basic elements using subcircuit definitions. This makes it possible to have the elements of these subcircuits available for the definition of the signal source, the detector or the loop gain reference. 

Execution of in instruction
---------------------------

Before execution of an instruction, all instruction data is copied to an instance of the **SLiCAPprotos.allResults** object. This instance is then used for execution of the instruction. This makes it possible to store instruction settings and results together, while later modification of the instruction data is not reflected in execution results obtained earlier. This, however, is not the case for changes in the **SLiCAPinstruction.circuit** object, because the **SLiCAPprotos.allResults.circuit** attribute is *not* a *deep copy* of the **SLiCAPinstruction.circuit** object.

To do
-----

#. makeNetlist()
#. Update makeServoBandwidth() requires a better estimate of the mid-band value of the loop gain 'mbv'.

Improvements
------------

#. Run maxima CAS in socket and communicate input and output in terminal, python IDE or notebook.
#. Make both maxima functions and sympy versions of math functions and a let the user user select the CAS per math function
#. Different report structure:
   #. Labels for all objects in a report
   #. Organize labels and generate report from the labels

Future
======

On the long term, SLiCAP should become part of an algorithm-driven analog design automation program. Such a progam must be able to generate design data based on:

#. Functional specification
#. Performance specification of the function(s)
#. Cost factor specification of the implementation
#. Specification of the operating environment

For interactive design (human <--> AI system), design data generated by the program should be in a human readable form:

#. Expressions
#. Schematics
#. Plots

Schematics and plots can be generated by a SLiCAP-like program. Such a program can be based on maxima CAS (LISP) or written in C++ using the GiNaC library. 

Solutions for generating human-readable schematics from a matrix description or from a netlist are (yet) unknown.
