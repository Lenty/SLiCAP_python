

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>SLiCAPmath.py &mdash; SLiCAP 1.5.0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/myStyle.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SLiCAPlex.py" href="SLiCAPlex.html" />
    <link rel="prev" title="SLiCAPprotos.py" href="SLiCAPprotos.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> SLiCAP
          

          
          </a>

          
            
            
              <div class="version">
                1.5.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/SLiCAPintroduction.html">SLiCAP introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userguide/SLiCAPuserguide.html">SLiCAP user guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../syntax/SLiCAPnetlistSyntax.html">SLiCAP netlist syntax</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development/SLiCAPdevelopment.html">SLiCAP development</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="SLiCAPreference.html">SLiCAP reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="SLiCAPnotebook.html">SLiCAPnotebook.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAP.html">SLiCAP.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPdesignData.html">SLiCAPdesignData.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPinstruction.html">SLiCAPinstruction.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPexecute.html">SLiCAPexecute.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPyacc.html">SLiCAPyacc.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPhtml.html">SLiCAPhtml.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPplots.html">SLiCAPplots.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPpythonMaxima.html">SLiCAPpythonMaxima.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPmatrices.html">SLiCAPmatrices.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPprotos.html">SLiCAPprotos.py</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SLiCAPmath.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPlex.html">SLiCAPlex.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPini.html">SLiCAPini.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPsetting.html">SLiCAPsetting.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPconfig.html">SLiCAPconfig.py</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/SLiCAPtutorials.html">SLiCAP tutorials</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SLiCAP</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="SLiCAPreference.html">SLiCAP reference</a> &raquo;</li>
        
      <li>SLiCAPmath.py</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/reference/SLiCAPmath.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-SLiCAP.SLiCAPmath.SLiCAPmath">
<span id="slicapmath-py"></span><h1>SLiCAPmath.py<a class="headerlink" href="#module-SLiCAP.SLiCAPmath.SLiCAPmath" title="Permalink to this headline">¶</a></h1>
<p>SLiCAP module with math functions.</p>
<p>Imported by the module <strong>SLiCAPprotos.py</strong>.</p>
<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.PdBm2V">
<code class="descname">PdBm2V</code><span class="sig-paren">(</span><em>p</em>, <em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.PdBm2V" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RMS value of the voltage that generates <em>p</em> dBm power
in a resistor with resistance <em>r</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p</strong> (<em>sympy.Symbol</em><em>, </em><em>sympy.Expression</em><em>, </em><em>int</em><em>, or </em><em>float</em>) – Power in dBm</li>
<li><strong>r</strong> (<em>sympy.Symbol</em><em>, </em><em>sympy.Expression</em><em>, </em><em>int</em><em>, or </em><em>float</em>) – Resistance</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">voltage</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">sympy.Expression</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.assumePosParams">
<code class="descname">assumePosParams</code><span class="sig-paren">(</span><em>expr</em>, <em>params='all'</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.assumePosParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sympy expression ‘expr’ in which  variables, except the
Laplace variable, have been redefined as real.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>expr</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em>) – Sympy expression</li>
<li><strong>params</strong> (<em>list</em><em>, </em><em>str</em>) – List with variable names (<em>str</em>), or ‘all’ or a variable name (<em>str</em>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Expression with redefined variables.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">sympy.Expr, sympy.Symbol</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.assumeRealParams">
<code class="descname">assumeRealParams</code><span class="sig-paren">(</span><em>expr</em>, <em>params='all'</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.assumeRealParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sympy expression ‘expr’ in which variables, except the
Laplace variable, have been redefined as real.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>expr</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em>) – Sympy expression</li>
<li><strong>params</strong> (<em>list</em><em>, </em><em>str</em>) – List with variable names (<em>str</em>), or ‘all’ or a variable name (<em>str</em>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Expression with redefined variables.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">sympy.Expr, sympy.Symbol</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.besselPoly">
<code class="descname">besselPoly</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.besselPoly" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a normalized Bessel polynomial of the n-th order of the Laplace 
variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>int</em>) – order</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Bessel polynomial of the n-th order of the Laplace variable</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">sympy.Expression</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.butterworthPoly">
<code class="descname">butterworthPoly</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.butterworthPoly" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a narmalized Butterworth polynomial of the n-th order of the 
Laplace variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>int</em>) – order</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Butterworth polynomial of the n-th order of the Laplace variable</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">sympy.Expression</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.cancelPZ">
<code class="descname">cancelPZ</code><span class="sig-paren">(</span><em>poles</em>, <em>zeros</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.cancelPZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancels poles and zeros that coincide within the displayed accuracy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The display accuracy (number of digits) is defined by ini.disp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>poles</strong> (<em>list</em>) – List with poles (<em>float</em>) of a Laplace rational function.</li>
<li><strong>zeros</strong> (<em>list</em>) – List with zeros (<em>float</em>) of a Laplace rational function.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Tuple with a list with poles (<em>float</em>) and a list with zeros (<em>float</em>).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Tuple with two lists,</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.checkExpression">
<code class="descname">checkExpression</code><span class="sig-paren">(</span><em>expr</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.checkExpression" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sympy expression of expr.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>expr</strong> (<em>str</em><em>, </em><em>sympy object</em><em>, </em><em>int</em><em>, </em><em>float</em>) – argument that may represent a number or an expression.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">sympy expression</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int, float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.checkNumber">
<code class="descname">checkNumber</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.checkNumber" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a number with its value represented by var.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>var</strong> (<em>str</em><em>, </em><em>sympy object</em><em>, </em><em>int</em><em>, </em><em>float</em>) – Variable that may represent a number.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">sympy expression</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int, float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.clearAssumptions">
<code class="descname">clearAssumptions</code><span class="sig-paren">(</span><em>expr</em>, <em>params='all'</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.clearAssumptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sympy expression ‘expr’ in which  the assumtions ‘Real’ and
‘Positive’ have been deleted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>expr</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em>) – Sympy expression</li>
<li><strong>params</strong> (<em>list</em><em>, </em><em>str</em>) – List with variable names (<em>str</em>), or ‘all’ or a variable name (<em>str</em>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Expression with redefined variables.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">sympy.Expr, sympy.Symbol</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.coeffsTransfer">
<code class="descname">coeffsTransfer</code><span class="sig-paren">(</span><em>rational</em>, <em>variable=s</em>, <em>normalize='lowest'</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.coeffsTransfer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a nested list with the coefficients of the variable of the
numerator and of the denominator of ‘rational’.</p>
<p>The coefficients are in ascending order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>rational</strong> (<em>sympy.Expr</em>) – Rational function of the variable.</li>
<li><strong>variable</strong> (<em>sympy.Symbol</em>) – Variable of the rational function</li>
<li><strong>normalize</strong> (<em>str</em>) – <p>Normalization method:</p>
<ul>
<li>”highest”: the coefficients of the highest order of 
&lt;variable&gt; of the denominator will be noramalized to unity.</li>
<li>”lowest”: the coefficients of the lowest order of 
&lt;variable&gt; of the denominator will be noramalized to unity.</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>Tuple with gain and two lists: [gain, numerCoeffs, denomCoeffs]</p>
<ol class="arabic simple">
<li>gain (<em>sympy.Expr</em>): ratio of the nonzero coefficient of the
lowest order of the numerator and the coefficient of the
nonzero coefficient of the lowest order of the denominator.</li>
<li>numerCoeffs  (<em>list</em>): List with all coeffcients of the
numerator in ascending order.</li>
<li>denomCoeffs  (<em>list</em>): List with all coeffcients of the
denominator in ascending order.</li>
</ol>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.dBmagFunc_f">
<code class="descname">dBmagFunc_f</code><span class="sig-paren">(</span><em>LaplaceExpr</em>, <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.dBmagFunc_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the dB magnitude at the real frequency f (Fourier) from the
univariate function ‘LaplaceExpr’ of the Laplace variable.</p>
<p>If ini.Hz == true, the Laplace variable will be replaced with
2*sp.pi*sp.I*ini.frequency.</p>
<p>If ini.Hz == False, the Laplace variable will be replaced with
sp.I*ini.frequency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>LaplaceExpr</strong> (<em>sympy.Expr</em>) – Univariate function of the Laplace variable.</li>
<li><strong>f</strong> – Frequency value (<em>float</em>), or a numpy array with frequency values
(<em>float</em>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dB Magnitude at the specified frequency, or list with dB magnitudes
at the specified frequencies.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float, numpy.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.delayFunc_f">
<code class="descname">delayFunc_f</code><span class="sig-paren">(</span><em>LaplaceExpr</em>, <em>f</em>, <em>delta=0.0001</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.delayFunc_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the group delay at the real frequency f (Fourier) from the
univariate function ‘LaplaceExpr’ of the Laplace variable.</p>
<p>If ini.Hz == true, the Laplace variable will be replaced with
2*sp.pi*sp.I*ini.frequency.</p>
<p>If ini.Hz == False, the Laplace variable will be replaced with
sp.I*ini.frequency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>LaplaceExpr</strong> (<em>sympy.Expr</em>) – Univariate function of the Laplace variable.</li>
<li><strong>f</strong> – Frequency value (<em>float</em>), or a numpy array with frequency values
(<em>float</em>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Group delay at the specified frequency, or list with group delays
at the specified frequencies.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float, numpy.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.det">
<code class="descname">det</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.det" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the determinant of a square matrix ‘M’ calculated using recursive 
minor expansion (Laplace expansion).
For large matrices with symbolic entries, this is faster than the built-in
sympy.Matrix.det() method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>M</strong> (<em>sympy.Matrix</em>) – Sympy matrix</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Determinant of ‘M’</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">sympy.Expr</td>
</tr>
<tr class="field-even field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;m_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D1</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t2</span><span class="o">=</span><span class="n">time</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D2</span> <span class="o">=</span> <span class="n">determinant</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t3</span><span class="o">=</span><span class="n">time</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;M.det :&#39;</span><span class="p">,</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;det(M):&#39;</span><span class="p">,</span> <span class="n">t3</span><span class="o">-</span><span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">D1</span><span class="o">-</span><span class="n">D2</span><span class="p">))</span>
<span class="go">M.det : 150.64841532707214 s</span>
<span class="go">det(M): 0.4860818386077881 s</span>
<span class="go">0</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.doCDS">
<code class="descname">doCDS</code><span class="sig-paren">(</span><em>noiseResult</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.doCDS" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns noiseResult after multiplying it with (2*sin(pi*ini.frequency*tau))^2</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>noiseResult</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em><em>, </em><em>int</em><em> or </em><em>float</em>) – sympy expression of a noise density spectrum in V^2/Hz or A^2/Hz</li>
<li><strong>tau</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em><em>, </em><em>int</em><em> or </em><em>float</em>) – Time between two samples</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">noiseResult*(2*sin(pi*ini.frequency*tau))^2</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">sympy.Expr, sympy.Symbol, int or float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.doCDSint">
<code class="descname">doCDSint</code><span class="sig-paren">(</span><em>noiseResult</em>, <em>tau</em>, <em>f_min</em>, <em>f_max</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.doCDSint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the integral from ini.frequency = f_min to ini.frequency = f_max, 
of a noise spectrum after multiplying it with (2*sin(pi*ini.frequency*tau))^2</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>noiseResult</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em><em>, </em><em>int</em><em> or </em><em>float</em>) – sympy expression of a noise density spectrum in V^2/Hz or A^2/Hz</li>
<li><strong>tau</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em><em>, </em><em>int</em><em> or </em><em>float</em>) – Time between two samples</li>
<li><strong>f_min</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em><em>, </em><em>int</em><em> or </em><em>float</em>) – Lower limit of the integral</li>
<li><strong>f_max</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em><em>, </em><em>int</em><em> or </em><em>float</em>) – Upper limit of the integral</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">integral of the spectrum from f_min to f_max after corelated double sampling</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">sympy.Expr, sympy.Symbol, int or float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.equateCoeffs">
<code class="descname">equateCoeffs</code><span class="sig-paren">(</span><em>protoType</em>, <em>transfer</em>, <em>noSolve=[]</em>, <em>numeric=True</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.equateCoeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the solutions of the equation transferFunction = protoTypeFunction.</p>
<p>Both transfer and prototype should be Laplace rational functions.
Their numerators should be polynomials of the Laplace variable of equal
order and their denominators should be polynomials of the Laplace variable
of equal order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>protoType</strong> (<em>sympy.Expr</em>) – Prototype rational expression of the Laplace variable</li>
<li><strong>transfer</strong> – </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Transfer fucntion of which the parameters need to be
solved. The numerator and the denominator of this rational
expression should be of the same order as those of the
prototype.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>noSolve</strong> (<em>list</em>) – List with variables (<em>str, sympy.core.symbol.Symbol</em>) that do not need
to be solved. These parameters will remain symbolic in the
solutions.</li>
<li><strong>numeric</strong> (<em>bool</em>) – True will force Maxima to use (big) floats for numeric
values.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>Dictionary with key-value pairs:</p>
<ul class="simple">
<li>key: name of the parameter (<em>sympy.core.symbol.Symbol</em>)</li>
<li>value: solution of this parameter: (<em>sympy.Expr, int, float</em>)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">dict</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.findServoBandwidth">
<code class="descname">findServoBandwidth</code><span class="sig-paren">(</span><em>loopgainRational</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.findServoBandwidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the intersection points of the asymptotes of the magnitude of
the loopgain with unity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>loopgainRational</strong> – Rational function of the Laplace variable, that
represents the loop gain of a circuit.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Dictionary with key-value pairs:<ul class="simple">
<li>hpf: frequency of high-pass intersection</li>
<li>hpo: order at high-pass intersection</li>
<li>lpf: frequency of low-pass intersection</li>
<li>lpo: order at low-pass intersection</li>
<li>mbv: mid-band value of the loopgain (highest value at order = zero)</li>
<li>mbf: lowest freqency of mbv</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.fullSubs">
<code class="descname">fullSubs</code><span class="sig-paren">(</span><em>valExpr</em>, <em>parDefs</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.fullSubs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns ‘valExpr’ after all parameters of ‘parDefs’ have been substituted
into it recursively until no changes occur or until the maximum number of
substitutions is achieved.</p>
<p>The maximum number opf recursive substitutions is set by ini.maxRexSubst.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>valExpr</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em><em>, </em><em>int</em><em>, </em><em>float</em>) – Eympy expression in which the parameters should be substituted.</li>
<li><strong>parDefs</strong> – <p>Dictionary with key-value pairs:</p>
<ul>
<li>key (<em>sympy.Symbol</em>): parameter name</li>
<li>value (<em>sympy object, int, float</em>): value of the parameter</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Expression or value obtained from recursive substitutions of
parameter definitions into ‘valExpr’.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">sympy object, int, float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.gainValue">
<code class="descname">gainValue</code><span class="sig-paren">(</span><em>numer</em>, <em>denom</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.gainValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the zero frequency (s=0) value of numer/denom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>numer</strong> (<em>sympy.Expr</em>) – Numerator of a rational function of the Laplace variable</li>
<li><strong>denom</strong> (<em>sympy.Expr</em>) – Denominator of a rational function of the Laplace variable</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">zero frequency (s=0) value of numer/denom.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">sympy.Expr</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.magFunc_f">
<code class="descname">magFunc_f</code><span class="sig-paren">(</span><em>LaplaceExpr</em>, <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.magFunc_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the magnitude at the real frequency f (Fourier) from the
univariate function ‘LaplaceExpr’ of the Laplace variable.</p>
<p>If ini.Hz == true, the Laplace variable will be replaced with
2*sp.pi*sp.I*ini.frequency.</p>
<p>If ini.Hz == False, the Laplace variable will be replaced with
sp.I*ini.frequency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>LaplaceExpr</strong> (<em>sympy.Expr</em>) – Univariate function of the Laplace variable.</li>
<li><strong>f</strong> – Frequency value (<em>float</em>), or a numpy array with frequency values
(<em>float</em>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Magnitude at the specified frequency, or list with magnitudes at
the specified frequencies.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float, numpy.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.mag_f">
<code class="descname">mag_f</code><span class="sig-paren">(</span><em>LaplaceExpr</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.mag_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the magnitude as a function of the real frequency f (Fourier)
from the Laplace function ‘LaplaceExpr’.</p>
<p>If ini.Hz == true, the Laplace variable will be replaced with
2*sp.pi*sp.I*ini.frequency.</p>
<p>If ini.Hz == False, the Laplace variable will be replaced with
sp.I*ini.frequency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>LaplaceExpr</strong> (<em>sympy.Expr</em>) – Univariate function of the Laplace variable.</li>
<li><strong>f</strong> – Frequency value (<em>float</em>), or a numpy array with frequency values
(<em>float</em>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Sympy expression representing the magnitude of the Fourier Transform.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">sympy.Expr</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.makeNumData">
<code class="descname">makeNumData</code><span class="sig-paren">(</span><em>yFunc</em>, <em>xVar</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.makeNumData" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of values y, where y[i] = yFunc(x[i]).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>yFunc</strong> (<em>sympy.Expr</em>) – Function</li>
<li><strong>xVar</strong> (<em>sympy.Symbol</em>) – Variable that needs to be substituted in <em>yFunc</em></li>
<li><strong>x</strong> (<em>list</em>) – List with values of x</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list with y values: y[i] = yFunc(x[i]).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.normalizeRational">
<code class="descname">normalizeRational</code><span class="sig-paren">(</span><em>rational</em>, <em>var=s</em>, <em>method='lowest'</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.normalizeRational" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalizes a rational expression to:</p>
<div class="math notranslate nohighlight">
\[F(s) = gain\,s^{\ell}  \frac{1+b_1s + ... + b_ms^m}{1+a_1s + ... + a_ns^n}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Rational</strong> (<em>sympy.Expr</em>) – Rational function of the variable.</li>
<li><strong>variable</strong> (<em>sympy.Symbol</em>) – Variable of the rational function</li>
<li><strong>method</strong> (<em>str</em>) – <p>Normalization method:</p>
<ul>
<li>”highest”: the coefficients of the highest order of 
&lt;variable&gt; of the denominator will be noramalized to unity.</li>
<li>”lowest”: the coefficients of the lowest order of 
&lt;variable&gt; of the denominator will be noramalized to unity.</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Normalized rational function of the variable.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">sympy.Expr</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.numRoots">
<code class="descname">numRoots</code><span class="sig-paren">(</span><em>expr</em>, <em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.numRoots" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the roots of the polynomial ‘expr’ with indeterminate ‘var’.</p>
<p>This function uses numpy for calculation of numeric roots.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>See: <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyroots.html">https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyroots.html</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>expr</strong> (<em>sympy.Expr</em>) – Univariate function.</li>
<li><strong>var</strong> (<em>sympy.Symbol</em>) – Indeterminate of ‘expr’.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.phaseFunc_f">
<code class="descname">phaseFunc_f</code><span class="sig-paren">(</span><em>LaplaceExpr</em>, <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.phaseFunc_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the phase angle at the real frequency f (Fourier) from the
univariate function ‘LaplaceExpr’ of the Laplace variable.</p>
<p>If ini.Hz == true, the Laplace variable will be replaced with
2*sp.pi*sp.I*ini.frequency.</p>
<p>If ini.Hz == False, the Laplace variable will be replaced with
sp.I*ini.frequency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>LaplaceExpr</strong> (<em>sympy.Expr</em>) – Univariate function of the Laplace variable.</li>
<li><strong>f</strong> – Frequency value (<em>float</em>), or a numpy array with frequency values
(<em>float</em>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Angle at the specified frequency, or list with angles at
the specified frequencies.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float, numpy.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.phaseMargin">
<code class="descname">phaseMargin</code><span class="sig-paren">(</span><em>LaplaceExpr</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.phaseMargin" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the phase margin assuming a loop gain definition according to
the asymptotic gain model.</p>
<p>This function uses <strong>scipy.newton()</strong> for determination of the the
unity-gain frequency. It uses the function <strong>SLiCAPmath.findServoBandwidth()</strong>
for the initial guess, and ini.disp for the relative accuracy.</p>
<p>if ini.Hz == True, the units will be degrees and Hz, else radians and
radians per seconds.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>LaplaceExpr</strong> (<em>sympy.Expr</em><em>, </em><em>list</em>) – Univariate function (sympy.Expr*) or list with
univariate functions (sympy.Expr*) of the Laplace
variable.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Tuple with phase margin (<em>float</em>) and unity-gain frequency
(<em>float</em>), or Tuple with lists with phase margins (<em>float</em>) and
unity-gain frequencies (<em>float</em>).</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.phase_f">
<code class="descname">phase_f</code><span class="sig-paren">(</span><em>LaplaceExpr</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.phase_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the magnitude as a function of the real frequency f (Fourier)
from the Laplace function ‘LaplaceExpr’.</p>
<p>If ini.Hz == true, the Laplace variable will be replaced with
2*sp.pi*sp.I*ini.frequency.</p>
<p>If ini.Hz == False, the Laplace variable will be replaced with
sp.I*ini.frequency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>LaplaceExpr</strong> (<em>sympy.Expr</em>) – Univariate function of the Laplace variable.</li>
<li><strong>f</strong> – Frequency value (<em>float</em>), or a numpy array with frequency values
(<em>float</em>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Sympy expression representing the phase of the Fourier Transform.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">sympy.Expr</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.polyCoeffs">
<code class="descname">polyCoeffs</code><span class="sig-paren">(</span><em>expr</em>, <em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.polyCoeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list with coefficients of ‘var’ in descending order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>expr</strong> (<em>sympy.Expr</em>) – Sympy expression</li>
<li><strong>var</strong> (<em>sympy.Symbol</em>) – Indeterminate of the polynomial.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">List with coefficients (<em>sympy.Expr</em>) in descending order.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.rmsNoise">
<code class="descname">rmsNoise</code><span class="sig-paren">(</span><em>noiseResult</em>, <em>noise</em>, <em>fmin</em>, <em>fmax</em>, <em>source=None</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.rmsNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the RMS source-referred noise or detector-referred noise,
or the contribution of a specific noise source to it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>noiseResult</strong> (<a class="reference internal" href="SLiCAPprotos.html#SLiCAP.SLiCAPprotos.SLiCAPprotos.allResults" title="SLiCAP.SLiCAPprotos.SLiCAPprotos.allResults"><em>SLiCAPprotos.allResults</em></a>) – Results of the execution of an instruction with data type ‘noise’.</li>
<li><strong>noise</strong> – ‘inoise’ or ‘onoise’ for source-referred noise or detector-
referred noise, respectively.</li>
<li><strong>fmin</strong> (<em>str</em><em>, </em><em>int</em><em>, </em><em>float</em><em>, </em><em>sp.Symbol</em>) – Lower limit of the frequency range in Hz.</li>
<li><strong>fmax</strong> (<em>str</em><em>, </em><em>int</em><em>, </em><em>float</em><em>, </em><em>sp.Symbol</em>) – Upper limit of the frequency range in Hz.</li>
<li><strong>source</strong> – ‘all’ or refDes (ID) of a noise source of which the
contribution to the RMS noise needs to be evaluated. Only
IDs of current of voltage sources with a nonzero value
for ‘noise’ are accepted.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>RMS noise over the frequency interval.</p>
<ul class="simple">
<li>An expression or value if parameter stepping of the instruction is disabled.</li>
<li>A list with expressions or values if parameter stepping of the instruction is enabled.</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int, float, sympy.Expr, list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.routh">
<code class="descname">routh</code><span class="sig-paren">(</span><em>charPoly</em>, <em>eps=epsilon</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.routh" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Routh array of a polynomial of the Laplace variable (ini.Laplace).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>charPoly</strong> (<em>sympy.Expr</em>) – Expression that can be written as a polynomial of the Laplace variable (ini.Laplace).</li>
<li><strong>eps</strong> (<em>sympy.Symbol</em>) – Symbolic variable used to indicate marginal stability. Use a symbol that is not present in <em>charPoly</em>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Routh array</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">sympy.Matrix</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># ini.Laplace = sp.Symbol(&#39;s&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">,</span> <span class="n">eps</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;s, epsilon&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">charPoly</span> <span class="o">=</span> <span class="n">s</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">**</span><span class="mi">3</span><span class="o">+</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">routh</span><span class="p">(</span><span class="n">charPoly</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="c1"># Number of roots in the right half plane is equal to</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="c1"># the number of sign changes in the first column of the</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="c1"># Routh array</span>
<span class="go">Matrix([[1], [2], [k/2 + 5/2], [(k**2 + 2*k + 1)/(k + 5)], [k + 1]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="SLiCAP.SLiCAPmath.SLiCAPmath.step2PeriodicPulse">
<code class="descname">step2PeriodicPulse</code><span class="sig-paren">(</span><em>ft</em>, <em>t_pulse</em>, <em>t_period</em>, <em>n_periods</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.SLiCAPmath.step2PeriodicPulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a step response in a periodic pulse response. Works with symbolic
and numeric time functions.</p>
<p>For evaluation of numeric values, use the SLiCAP function: makeNumData().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ft</strong> (<em>sympy.Expr</em>) – Time function f(t)</li>
<li><strong>t_pulse</strong> (<em>int</em><em>, </em><em>float</em>) – Pulse width</li>
<li><strong>t_period</strong> (<em>int</em><em>, </em><em>float</em>) – Pulse period</li>
<li><strong>n_periods</strong> – Number of pulses</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Typen_periods:</th><td class="field-body"><p class="first">int, float</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">modified time function</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">sympy.Expr</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="SLiCAPlex.html" class="btn btn-neutral float-right" title="SLiCAPlex.py" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="SLiCAPprotos.html" class="btn btn-neutral float-left" title="SLiCAPprotos.py" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2023, SLiCAP development team.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>