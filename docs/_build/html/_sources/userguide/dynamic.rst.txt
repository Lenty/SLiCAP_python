==========================
Design of dynamic behavior
==========================

SLiCAP has a number of built-in scripts to support circuit designers with the analysis and design of the dynamic behavior of electronic circuits. Brief descriptions of the implemented functions have been listed below.

---------------------------------------------
Obtain the coefficients of a Laplace rational
---------------------------------------------

The function `coefsTransfer() <../reference/SLiCAPmath.html#SLiCAP.SLiCAPmath.SLiCAPmath.coeffsTransfer>`_ returns a tuple with:

- The gain
- A list of coefficients of the Laplace variable of the numerator in ascending order
- A list of coefficients of the Laplace variable of the denominator in ascending order 

All coefficients have been normalized to obtain unity for the coefficient of the lowest order of the denominator. The gain is then defined as the ratio of the coefficients of the lowest order of the numerator and the denominator. Both lists carry the coefficients in ascending order.

.. code-block:: python

    >>> from SLiCAP import *
    >>> rational_expr = sp.sympify('(b_0 + b_2*s^2)/(a_0 + a_1*s + a_2*s^2 + a_4*s^4)')
    >>> (gain, coeffs_numer, coeffs_denom) = coeffsTransfer(rational_expr)
    >>> print(gain)
    b_0/a_0
    >>> print(coeffs_numer)
    [1, 0, b_2/b_0]
    >>> print(coeffs_denom)
    [1, a_1/a_0, a_2/a_0, 0, a_4/a_0]

------------------------------------------------------
Determine circuit parameters from a prototype transfer
------------------------------------------------------

The function `equateCoeffs() <../reference/SLiCAPmath.html#SLiCAP.SLiCAPmath.SLiCAPmath.equateCoeffs>`_ can be used to find values of circuit elements such that the dynamic transfer of that circuit equals that of a prototype. This function is is particularly useful for the design of passive and active filters.

.. code-block:: python

    >>> from SLiCAP import *
    >>> proto_transfer = sp.sympify('0.3*(1/(1+s*0.6))')
    >>> # This could be a Laplace expression generated by SLiCAP:
    >>> circuit_transfer = sp.sympify('R_1/(R_1 + R_2)/(1 + s*R_1*R_2/(R_1 + R_2)*10e-6)')
    >>> circuit_component_values = equateCoeffs(proto_transfer, circuit_transfer)
    >>> print(circuit_component_values)
    {R_2: 200000.000000000, R_1: 85714.2857142857}
    >>> proto_transfer = sp.sympify('A/(1+s*tau)')
    >>> circuit_component_values = equateCoeffs(proto_transfer, circuit_transfer, noSolve=['A','tau'], numeric=False)
    >>> print circuit_component_values
    {R_2: 100000.0*tau/A, R_1: -100000.0*tau/(A - 1.0)}

---------------------------------------------------------------------
Estimate the bandwith and system order of a negative-feedback circuit
---------------------------------------------------------------------

The function `findServoBandwidth() <../reference/SLiCAPmath.html#SLiCAP.SLiCAPmath.SLiCAPmath.findServoBandwidth>`_ facilitates the design of the small-signal bandwidth of negative feedback amplifiers. 
    
With the loop gain reference variable properly selected, the dynamic behavior of a negative feedback amplifier is the product its ideal gain and the servo function. The servo function is determined by the loop gain. If the loop gain reaches infinity, the servo fuction approaches unity. The bandwidth of the servo functions is a measure for the frequency range over which the gain of a negative feedback system approaches its ideal gain.

The function `findServoBandwidth() <../reference/SLiCAPmath.html#SLiCAP.SLiCAPmath.SLiCAPmath.findServoBandwidth>`_ determines the unity gain frequencies of the asymptotes of the magnitude characteristic of the loop gain. It assumes a single passband, low-pass, band-pass or high-pass behavior of the servo function. This means that there are maximally two unity gain frequencies of the loop gain. The function returns:

- The frequencies of intersection of the asymptoties of the magnitude characteristic of the loop gain and unity
- The order (slope) at these frequencies
- The maximum asymptotic value of the magnitude of the loop gain and its first frequency of occurence.
    
The function argument can be obtained from the execution of an instruction with the data type set to *laplace* and its gain type set to *loopgain*.

.. code-block:: python

    >>> from SLiCAP import *  
    >>> loopgain_numer   = sp.sympify('-s*(1 + s/20)*(1 + s/40)/2')
    >>> loopgain_denom   = sp.sympify('(s + 1)^2*(1 + s/4e3)*(1 + s/50e3)*(1 + s/1e6)')
    >>> loopgain         = loopgain_numer/loopgain_denom
    >>> servo_info       = findServoBandwidth(loopgain)
    >>> print(servo_info)
    {'mbf': 636.61977236758094, 'lpo': -1.0, 'hpo': 1.0, 'lpf': 19894.367886486925, 'mbv': 2.5000000000000009, 'hpf': 254.64790894703231}

Hence, the servo function has a first-order low-frequency cut-off at about 1.6krad/s (254.65 Hz) and a first-order high-frequency cut-off at about 125krad/s (19.8944 kHz). The mid-band of the loop gain equals -2.5 at 4000rad/s (636.62Hz]. The result for this situation has been shown below_.
    
.. _below:

	.. figure:: /img/BWexample.svg
	 	:width: 800
	 	:alt: Estimation of the bandwidth of the servo function from the asymptotes of the magnitude characteristic of the loop gain

		Estimation of the bandwidth of the servo function from the asymptotes of the magnitude characteristic of the loop gain
