#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
SLiCAP module with extended matrix class and SLiCAP math functions.

Imported by the module **SLiCAPprotos.py**.
"""
from SLiCAP.SLiCAPlex import *

class matrix(sp.Matrix):
    """
    SLiCAP matrix class for symbolic calculations.

    This class is an extension to the sympy Matrix class. It calculates
    determinants using minor expansion. This is slow for large matrices.

    SLiCAP uses Maxima CAS for calculation of determinants.

    Return types for matrices are <class 'sympy.matrices.matrices.Matrix'>.

    Adapted from: from "Bill McNeill <billmcn@speakeasy.net>"

    **Added**

    - Test for matrix element == zero, speeds up calculation of sparse matrices.

    **Removed**

    - Checks for square matrices: the matrix generated by SLiCAP is square.

    **Modified**

    - Updated to the latest version of sympy.
    """
    def __init__(self, M):
        pass

    def minor(self, i, j):
        """
        Returns determinant of M after deleting row i and column j.
        """
        return matrix(self.minor_submatrix(i, j)).determinant()

    def coFactor(self, i, j):
        """
        Returns cofactor C(i,j).
        """
        if (i + j)%2 == 0:
            return self.minor(i, j)
        else:
            return -self.minor(i, j)

    def determinant(self):
        """
        Returns determinant of a 2 x 2 matrix.
        """
        if self.shape[0] == 1:
            d = self[0,0]
        elif self.shape[0] == 2:
            d = self[0,0]*self[1,1] - self[0,1]*self[1,0]
        else:
            d = self.expandByMinorsRows()
        return sp.expand(d)
        
    def expandByMinorsRows(self):
        """
        Calculates (sub)determinant by expansion of minors.
        """
        d = 0
        for col in range(self.shape[1]):
            if self[0, col] != 0:
                if col%2 == 0:
                    d += self[0, col]*self.minor(0 , col)
                else:
                    d -= self[0, col]*self.minor(0 , col)
        return d
        
    def expandByMinorsCols(self):
        """
        Calculates (sub)determinant by expansion of minors.
        """
        d = 0
        for row in range(self.shape[0]):
            if self[row, 0] != 0:
                if row%2 == 0:
                    d += self[row, 0]*self.minor(row, 0)
                else:
                    d -= self[row, 0]*self.minor(row, 0)
        return d

    def coFactorMatrix(self):
        """
        Returns the cofactor matrix of M.
        """
        C = sp.zeros(self.shape[0])
        for i in range(self.shape[0]):
            for j in range(self.shape[1]):
                C[i,j] = self.coFactor(i, j)
        return C

    def adjugate(self):
        """
        Returns the adjugate (transposed cofactor matrix) matrix of M.
        """
        return self.coFactorMatrix().transpose()

    def inverse(self):
        """
        Returns inverse matrix of M
        """
        return self.adjugate()/self.determinant()

    def dotV(self, Vr, Vc):
        """
        Returns the dot product of row vector Vr and column vector Vc.
        """
        s1 = Vr.shape
        result = 0
        for i in range(s1[1]):
            if Vr[i] == 0 or Vc[i] == 0:
                pass
            elif Vr[i] == 1:
                result += Vc[i]
            elif Vc[i] == 1:
                result += Vr[i]
            elif Vr[i] == -1:
                result += -Vc[i]
            elif Vc[i] == -1:
                result += -Vr[i]
            else:
                result += Vr[i]*Vc[i]
        return result

    def dot(self, M2):
        """
        Returns the dot product of two matrices M1 and M2
        """
        s1 = self.shape
        s2 = M2.shape
        if s1[1] == s2[0]:
            mult = sp.zeros(s1[0],s2[1])
            for i in range(s1[0]):
                for j in range(s2[1]):
                    mult[i,j] = self.dotV(self[i,:],M2[:,j])
            return mult
        else:
            print('Incompatible matrix dimensions')

    def Cramer(self, colVector, colNumber):
        """
        Returns matrix with colVector substituted in column colNumber
        """
        newMatrix = matrix(sp.zeros(self.rows, self.cols))
        for i in range(self.rows):
            for j in range(self.cols):
                newMatrix[i,j] = self[i,j]
        newMatrix[:,colNumber] = colVector
        return newMatrix

def polyCoeffs(expr, var):
    """
    Returns a list with coefficients of 'var' in descending order.

    :param expr: Sympy expression
    :type expr: sympy.Expr

    :param var: Indeterminate of the polynomial.
    :type var: sympy.Symbol

    :return: List with coefficients (*sympy.Expr*) in descending order.
    :rtype: list
    """

    if isinstance(expr, sp.Basic) and isinstance(var, sp.Basic):
        return sp.Poly(expr, var).all_coeffs()
    else:
        return []

def numRoots(expr, var):
    """
    Returns the roots of the polynomial 'expr' with indeterminate 'var'.

    This function uses numpy for calculation of numeric roots.

    :note:

    See: https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyroots.html

    :param expr: Univariate function.
    :type expr: sympy.Expr

    :param var: Indeterminate of 'expr'.
    :type var: sympy.Symbol
    """
    if isinstance(expr, sp.Basic) and isinstance(var, sp.Basic):
        params = list(expr.atoms(sp.Symbol))
        try:
            params.remove(var)
            if len(params) != 0:
                print("Error: symbolic variables found, cannot determine roots of:", str(expr))
                return []
        except:
            return []
        try:
            coeffs = polyCoeffs(expr, ini.Laplace)
            roots = np.roots(np.array(coeffs))
            return np.flip(roots, 0)
        except:
            print("Error: cannot determine the roots of:", str(expr))
            return []
    return []

def makeLaplaceRational(gain, zeros, poles):
    """
    Creates a Laplace rational from a gain factor, a list of zeros and a list
    of poles:

    .. math::

        F(s) = gain \\frac{ \prod_j(s-z_j)} {\prod_i(s-p_i)}

    Terms with complex conjugated poles or zeros will be combined into
    quadratic terms.

    The gain factor should be taken as

    This function is used for evaluation of the inverse Laplace transform
    of rational functions in the Laplace variable 's' with Maxima CAS.

    :param gain: The ratio of the coefficients of the highest order of the
                 Laplace variable of the numerator and the denominator;
                 this is not the DC gain!
    :type gain: int, float, sympy.Symbol, sympy.Expr

    :param zeros: List with solutions of the Laplace variable of the numerator
                  of :math:`F(s)`.

    :param poles: List with solutions of the Laplace variable of the
                  denominator of :math:`F(s)`.

    :return: :math:`F(s)`
    :rtype: sympy.Expr

    """
    Fs = gain
    for z in zeros:
        if sp.im(z) == 0:
            Fs *= (ini.Laplace-z)
        elif sp.im(z) > 0:
            Fs *= (ini.Laplace**2 - 2*sp.re(z) + sp.re(z)**2 + sp.im(z)**2)
    for p in poles:
        if sp.im(p) == 0:
            Fs /= (ini.Laplace-p)
        elif sp.im(p) > 0:
            Fs /= (ini.Laplace**2 - 2*sp.re(p)*ini.Laplace + sp.re(p)**2 + sp.im(p)**2)
    return(Fs)

def coeffsTransfer(LaplaceRational):
    """
    Returns a nested list with the coefficients of the Laplace variable of the
    numerator and of the denominator of 'LaplaceRational'.

    The coefficients are in ascending order.

    :param LaplaceRational: Rational function of the Laplace variable.
    :type LaplaceRational: sympy.Expr

    :return: Tuple with gain and two lists: [gain, numerCoeffs, denomCoeffs]

             #. gain (*sympy.Expr*): ratio of the nonzero coefficient of the
                lowest order of the numerator and the coefficient of the
                nonzero coefficient of the lowest order of the denominator.
             #. numerCoeffs  (*list*): List with all coeffcients of the
                numerator in ascending order.
             #. denomCoeffs  (*list*): List with all coeffcients of the
                denominator in ascending order.

    :rtype: tuple
    """
    try:
        LaplaceRational = sp.simplify(LaplaceRational)
    except:
        pass
    numer, denom = LaplaceRational.as_numer_denom()
    coeffsNumer = polyCoeffs(numer, ini.Laplace)
    coeffsDenom = polyCoeffs(denom, ini.Laplace)
    coeffsNumer.reverse()
    for i in range(len(coeffsNumer)):
        coeffsNumer[i] = sp.factor(coeffsNumer[i])
    coeffsDenom.reverse()
    for i in range(len(coeffsDenom)):
        coeffsDenom[i] = sp.factor(coeffsDenom[i])
    coeffN = 1
    coeffD = 1
    gain   = 1
    found = False
    i = 0
    while not found and i < len(coeffsNumer):
        if coeffsNumer[i] != 0:
            found = True
            coeffN = coeffsNumer[i]
        i += 1
    found = False
    i = 0
    while not found and i < len(coeffsDenom):
        if coeffsDenom[i] != 0.:
            found = True
            coeffD = coeffsDenom[i]
        i += 1
    gain = coeffN/coeffD
    for j in range(len(coeffsNumer)):
        coeffsNumer[j] = coeffsNumer[j]/coeffN
        try:
            coeffsNumer[j] = sp.simplify(coeffsNumer[j])
        except:
            pass
    for j in range(len(coeffsDenom)):
        coeffsDenom[j] = coeffsDenom[j]/coeffD
        try:
            coeffsDenom[j] = sp.simplify(coeffsDenom[j])
        except:
            pass
    return (gain, coeffsNumer, coeffsDenom)

def normalizeLaplaceRational(LaplaceRational):
    """
    Normalizes a Laplace rational to:

    .. math::

        F(s) = gain\,s^{\ell}  \\frac{1+b_1s + ... + b_ms^m}{1+a_1s + ... + a_ns^n}

    :param LaplaceRational: Rational function of the Laplace variable.
    :type LaplaceRational: sympy.Expr

    :return:  Normalized rational function of the Laplace variable.
    :rtype: sympy.Expr
    """
    gain, coeffsNumer, coeffsDenom = coeffsTransfer(sp.simplify(LaplaceRational))
    # find coefficient of ini.Laplace of the lowest order of the denominator:
    numer = 0
    denom = 0
    for j in range(len(coeffsNumer)):
        numer += coeffsNumer[j]*ini.Laplace**j
    for j in range(len(coeffsDenom)):
        denom += coeffsDenom[j]*ini.Laplace**j
    return gain*numer/denom

def cancelPZ(poles, zeros):
    """
    Cancels poles and zeros that coincide within the displayed accuracy.

    :note:

    The display accuracy (number of digits) is defined by ini.disp.

    :param poles: List with poles (*float*) of a Laplace rational function.
    :type poles: list

    :param zeros: List with zeros (*float*) of a Laplace rational function.
    :type zeros: list

    :return: Tuple with a list with poles (*float*) and a list with zeros (*float*).
    """
    newPoles = []
    newZeros = []
    # make a copy of the lists of poles and zeros, this one will be modified
    for i in range(len(poles)):
        newPoles.append(poles[i])
    for i in range(len(zeros)):
        newZeros.append(zeros[i])
    for i in range(len(poles)):
        for j in range(len(zeros)):
            if abs(sp.re(poles[i]) - sp.re(zeros[j])) <= 10**(-ini.disp)*abs(sp.re(poles[i]) + sp.re(zeros[j]))/2 \
            and abs(sp.im(poles[i]) - sp.im(zeros[j])) <= 10**(-ini.disp)*abs(sp.im(poles[i]) + sp.im(zeros[j]))/2 \
            and poles[i] in newPoles and zeros[j] in newZeros:
                newPoles.remove(poles[i])
                newZeros.remove(zeros[j])
    return(newPoles, newZeros)

def findServoBandwidth(loopgainRational):
    """
    Determines the intersection points of the asymptotes of the magnitude of
    the loopgain with unity.

    :param loopgainRational: Rational function of the Laplace variable, that
           represents the loop gain of a circuit.
    :type LoopgainRational: sympy.Expr

    :return: Dictionary with key-value pairs:

             - hpf: frequency of high-pass intersection
             - hpo: order at high-pass intersection
             - lpf: frequency of low-pass intersection
             - lpo: order at low-pass intersection
             - mbv: mid-band value of the loopgain (highest value at order = zero)
             - mbf: lowest freqency of mbv
    :rtype: dict
    """    
    try:
        LaplaceRational = sp.simplify(LaplaceRational)
        numer, denom    = loopgainRational.as_numer_denom()
    except:
        numer, denom    = loopgainRational.as_numer_denom()
        numer           = sp.expand(sp.collect(numer.evalf(), ini.Laplace))
        denom           = sp.expand(sp.collect(denom.evalf(), ini.Laplace))
    poles           = numRoots(denom, ini.Laplace)
    zeros           = numRoots(numer, ini.Laplace)
    poles, zeros = cancelPZ(poles, zeros)
    numPoles        = len(poles)
    numZeros        = len(zeros)
    numCornerFreqs  = numPoles + numZeros
    gain, coeffsN,coeffsD = coeffsTransfer(loopgainRational)
    coeffsN         = np.array(coeffsN)
    coeffsD         = np.array(coeffsD)
    firstNonZeroN   = np.argmax(coeffsN != 0)
    firstNonZeroD   = np.argmax(coeffsD != 0)
    startOrder      = firstNonZeroN - firstNonZeroD
    startValue      = np.abs(gain)
    """ array columns
        1. Corner frequency in rad/s
        2. Order change at that corner +n: n zeros, -n: n poles
        3. Cumulative order from corner frequency
        4. Cumulative LP product
        5. Asymptotic servo cut-off frequency in rad/s (can be low-pass or high-pass)
    """
    freqsOrders     = np.zeros((numCornerFreqs, 6))
    result = {}
    result['mbv'] = startValue # Needs improvement
    result['mbf'] = 0          # Needs improvement
    result['lpf'] = 0
    result['lpo'] = 0
    result['hpf'] = None
    result['hpo'] = 0
    for i in range(numZeros):
        freqsOrders[i, 0] = np.abs(zeros[i])
        freqsOrders[i, 1] = 1
    for i in range(numPoles):
        freqsOrders[numZeros + i, 0] = np.abs(poles[i])
        freqsOrders[numZeros + i, 1] = -1
    # sort the rows with increasing corner frequencies
    freqsOrders = freqsOrders[freqsOrders[:,0].argsort()]
    for i in range(numCornerFreqs):
        if i == 0:
            freqsOrders[i, 2] = startOrder
            if freqsOrders[i, 0] == 0:
                freqsOrders[i, 3] = startValue
                freqsOrders[i, 4] = startValue
                freqsOrders[i, 5] = 0
            else:
                freqsOrders[i, 2] = freqsOrders[i, 1] + freqsOrders[i-1, 2]
                freqsOrders[i, 3] = startValue*freqsOrders[i, 0]** -freqsOrders[i, 1]
                freqsOrders[i, 4] = startValue
        else:
            freqsOrders[i, 2] = freqsOrders[i, 1] + freqsOrders[i-1, 2]
            freqsOrders[i, 3] = freqsOrders[i-1, 3]*freqsOrders[i, 0]**-freqsOrders[i, 1]
            if freqsOrders[i-1, 0] == 0:
                freqsOrders[i, 4] = freqsOrders[i-1, 4] * freqsOrders[i, 0]**freqsOrders[i, 2]
            else:
                freqsOrders[i, 4] = freqsOrders[i-1, 4] * (freqsOrders[i, 0]/freqsOrders[i-1, 0])** freqsOrders[i-1, 2]
        if freqsOrders[i, 2] != 0:
            freqsOrders[i, 5] = freqsOrders[i, 3]**(-1/freqsOrders[i, 2])
            if freqsOrders[i, 5] > freqsOrders[i, 0]:
                if freqsOrders[i, 2] > 0:
                    result['hpf'] = freqsOrders[i, 5]
                    result['hpo'] = freqsOrders[i, 2]
                else:
                    result['lpf'] = freqsOrders[i, 5]
                    result['lpo'] = freqsOrders[i, 2]
        if freqsOrders[i, 4] > result['mbv'] and freqsOrders[i, 0] != 0:
            result['mbv'] = freqsOrders[i, 4]
            result['mbf'] = freqsOrders[i, 0]
    if result['mbf'] == 0:
        result['mbv'] = np.abs(loopgainRational.subs(ini.Laplace, 0))
    if ini.Hz:
        try:
            result['hpf'] = result['hpf']/np.pi/2
        except:
            pass
        try:
            result['lpf'] = result['lpf']/np.pi/2
        except:
            pass
        try:
            result['mbf'] = result['mbf']/np.pi/2
        except:
            pass
    return result

def checkNumber(var):
    """
    Returns a number with its value represented by var, or None if var
    does not represent a number.

    :param var: Variable that may represent a number.
    :type var: str, sympy object, int, float

    :return: Numeric value (*int, float*) or None
    :rtype: int, float, bool
    """

    if type(var) == str:
        var = replaceScaleFactors(var)
    else:
        var = str(var)
    try:
        number = eval(var)
        return number
    except:
        return None

def fullSubs(valExpr, parDefs):
    """
    Returns 'valExpr' after all parameters of 'parDefs' have been substituted
    into it recursively until no changes occur or until the maximum number of
    substitutions is achieved.

    The maximum number opf recursive substitutions is set by ini.maxRexSubst.

    :param valExpr: Eympy expression in which the parameters should be substituted.
    :type valExpr: sympy.Expr, sympy.Symbol, int, float

    :param parDefs: Dictionary with key-value pairs:

                    - key (*sympy.Symbol*): parameter name
                    - value (*sympy object, int, float*): value of the parameter

    :return: Expression or value obtained from recursive substitutions of
             parameter definitions into 'valExpr'.
    :rtype: sympy object, int, float
    """

    strValExpr = str(valExpr)
    i = 0
    newvalExpr = 0
    while valExpr != newvalExpr and i < ini.maxRecSubst and isinstance(valExpr, sp.Basic):
        # create a substitution dictionary with the smallest number of entries (this speeds up the substitution)
        substDict = {}
        params = list(valExpr.atoms(sp.Symbol))
        for param in params:
            if param in list(parDefs.keys()):
                substDict[param] = parDefs[param]
        # perform the substitution
        newvalExpr = valExpr
        valExpr = newvalExpr.xreplace(substDict)
        i += 1
    if i == ini.maxRecSubst:
        print("Warning: reached maximum number of substitutions for expression '{0}'".format(strValExpr))
    return valExpr

def assumeRealParams(expr, params = 'all'):
    """
    Returns the sympy expression 'expr' in which variables, except the
    Laplace variable, have been redefined as real.

    :param expr: Sympy expression
    :type expr: sympy.Expr, sympy.Symbol

    :param params: List with variable names (*str*), or 'all' or a variable name (*str*).
    :type params: list, str

    :return: Expression with redefined variables.
    :rtype: sympy.Expr, sympy.Symbol
    """

    if type(params) == list:
        for i in range(len(params)):
            expr = expr.xreplace({sp.Symbol(params[i]): sp.Symbol(params[i], real = True)})
    elif type(params) == str:
        if params == 'all':
            params = list(expr.atoms(sp.Symbol))
            try:
                params.remove(ini.Laplace)
            except:
                pass
            for i in range(len(params)):
                expr = expr.xreplace({sp.Symbol(str(params[i])): sp.Symbol(str(params[i]), real = True)})
        else:
            return expr.xreplace({sp.Symbol(params): sp.Symbol(params, real = True)})
    else:
        print("Error: expected type 'str' or 'lst', got '{0}'.".format(type(params)))
    return expr

def assumePosParams(expr, params = 'all'):
    """
    Returns the sympy expression 'expr' in which  variables, except the
    Laplace variable, have been redefined as real.

    :param expr: Sympy expression
    :type expr: sympy.Expr, sympy.Symbol

    :param params: List with variable names (*str*), or 'all' or a variable name (*str*).
    :type params: list, str

    :return: Expression with redefined variables.
    :rtype: sympy.Expr, sympy.Symbol
    """

    if type(params) == list:
        for i in range(len(params)):
            expr = expr.xreplace({sp.Symbol(params[i]): sp.Symbol(params[i], positive = True)})
    elif type(params) == str:
        if params == 'all':
            params = list(expr.atoms(sp.Symbol))
            try:
                params.remove(ini.Laplace)
            except:
                pass
            for i in range(len(params)):
                expr = expr.xreplace({sp.Symbol(str(params[i])): sp.Symbol(str(params[i]), positive = True)})
        else:
            return expr.xreplace({sp.Symbol(params): sp.Symbol(params, positive = True)})
    else:
        print("Error: expected type 'str' or 'lst', got '{0}'.".format(type(params)))
    return expr

def clearAssumptions(expr, params = 'all'):
    """
    Returns the sympy expression 'expr' in which  the assumtions 'Real' and
    'Positive' have been deleted.

    :param expr: Sympy expression
    :type expr: sympy.Expr, sympy.Symbol

    :param params: List with variable names (*str*), or 'all' or a variable name (*str*).
    :type params: list, str

    :return: Expression with redefined variables.
    :rtype: sympy.Expr, sympy.Symbol
    """
    
    if type(params) == list:
        for i in range(len(params)):
            expr = expr.xreplace({sp.Symbol(params[i], positive = True): sp.Symbol(params[i])})
            expr = expr.xreplace({sp.Symbol(params[i], real = True): sp.Symbol(params[i])})
    elif type(params) == str:
        if params == 'all':
            params = list(expr.atoms(sp.Symbol))
            try:
                params.remove(ini.Laplace)
            except:
                pass
            for i in range(len(params)):
                expr = expr.xreplace({sp.Symbol(str(params[i]), positive = True): sp.Symbol(str(params[i]))})
                expr = expr.xreplace({sp.Symbol(str(params[i]), real = True): sp.Symbol(str(params[i]))})
        else:
            expr = expr.xreplace({sp.Symbol(params, positive = True): sp.Symbol(params)})
            expr = expr.xreplace({sp.Symbol(params, real = True): sp.Symbol(params)})
    else:
        print("Error: expected type 'str' or 'lst', got '{0}'.".format(type(params)))
    return expr

def invLaplace(numer, denom):
    """
    Calculates the Inverse Laplace Transform of a numerical rational expression
    of which the sympy polynomials of the numerator and the denominator are
    passed as arguments, respecively.

    ToDo: This function is not used because of observed problems with residues
    at dominant pole-zero pairs. Instead maxILT() is used, which also supports
    the symbolic inverse Laplace Transform.

    :param numer: Univariate function of the Laplace variable.
    :type numer: sympy.Expr

    :param denom: Univariate function of the Laplace variable.
    :type denom: sympy.Expr

    :return: Inverse Laplace transform of numer/denom.
    :rtype: sympy.Expr
    """

    numer = np.poly1d(polyCoeffs(numer, ini.Laplace))
    numerCoeffs = [np.float(coeff) for coeff in numer.c]
    denom = np.poly1d(polyCoeffs(denom, ini.Laplace))
    denomCoeffs = [np.float(coeff) for coeff in denom.c]
    (r, p, k) = residue(numerCoeffs, denomCoeffs, tol=10**(-ini.disp))
    t = sp.Symbol('t')
    ft = 0
    m = 1
    for i in range(len(r)):
        p[i]=sp.sympify(str(p[i]))
        if i > 0:
            if abs(p[i] - p[i - 1]) < 10**(-ini.disp) * abs(p[i]):
                m += 1
            else:
                m = 1
        ft += (t**(m - 1)/sp.factorial(m - 1))*r[i]*sp.E**(p[i]*t)
    ft = ft.rewrite("cos").trigsimp()
    return ft

def phaseMargin(LaplaceExpr):
    """
    Calculates the phase margin assuming a loop gain definition according to
    the asymptotic gain model.

    This function uses **scipy.newton()** for determination of the the
    unity-gain frequency. It uses the function **SLiCAPmath.findServoBandwidth()**
    for the initial guess, and ini.disp for the relative accuracy.

    if ini.Hz == True, the units will be degrees and Hz, else radians and
    radians per seconds.

    :param LaplaceExpr: Univariate function (sympy.Expr*) or list with
                        univariate functions (sympy.Expr*) of the Laplace
                        variable.
    :type LaplaceExpr: sympy.Expr, list

    :return: Tuple with phase margin (*float*) and unity-gain frequency
             (*float*), or Tuple with lists with phase margins (*float*) and
             unity-gain frequencies (*float*).

    :rtype: tuple
    """

    if type(LaplaceExpr) != list:
        LaplaceExpr = [LaplaceExpr]
    freqs = []
    mrgns = []
    for expr in LaplaceExpr:
        if ini.Hz == True:
            data = expr.xreplace({ini.Laplace: 2*sp.pi*sp.I*ini.frequency})
        else:
            data = expr.xreplace({ini.Laplace: sp.I*ini.frequency})
        func = sp.lambdify(ini.frequency, sp.Abs(data)-1)
        guess = findServoBandwidth(expr)['lpf']
        try:
            #freq = newton(func, guess, tol = 10**(-ini.disp), maxiter = 50)
            freq = fsolve(func, guess)[0]
            mrgn = phaseFunc_f(expr, freq)
        except:
            print("Error: could not determine unity-gain frequency for phase margin.")
            freq = None
            mrgn = None
        freqs.append(freq)
        mrgns.append(mrgn)
    if len(freqs) == 1:
        return (mrgns[0], freqs[0])
    else:
        return (mrgns, freqs)

def magFunc_f(LaplaceExpr, f):
    """
    Calculates the magnitude at the real frequency f (Fourier) from the
    univariate function 'LaplaceExpr' of the Laplace variable.

    If ini.Hz == true, the Laplace variable will be replaced with
    2*sp.pi*sp.I*ini.frequency.

    If ini.Hz == False, the Laplace variable will be replaced with
    sp.I*ini.frequency.

    :param LaplaceExpr: Univariate function of the Laplace variable.
    :type LaplaceExpr: sympy.Expr

    :param f: Frequency value (*float*), or a numpy array with frequency values
              (*float*).

    :return: Magnitude at the specified frequency, or list with magnitudes at
             the specified frequencies.

    :rtype: float, numpy.array
    """

    if type(f) == list:
        # Convert lists into numpy arrays
        f = np.array(f)
    # Obtain the Fourier transform from the Laplace transform
    if ini.Hz == True:
        data = LaplaceExpr.xreplace({ini.Laplace: 2*sp.pi*sp.I*ini.frequency})
    else:
        data = LaplaceExpr.xreplace({ini.Laplace: sp.I*ini.frequency})
    if ini.frequency in list(data.atoms(sp.Symbol)):
        func = sp.lambdify(ini.frequency, sp.Abs(sp.N(data)))
        return func(f)
    else:
        return([abs(data) for i in range(len(f))])

def dBmagFunc_f(LaplaceExpr, f):
    """
    Calculates the dB magnitude at the real frequency f (Fourier) from the
    univariate function 'LaplaceExpr' of the Laplace variable.

    If ini.Hz == true, the Laplace variable will be replaced with
    2*sp.pi*sp.I*ini.frequency.

    If ini.Hz == False, the Laplace variable will be replaced with
    sp.I*ini.frequency.

    :param LaplaceExpr: Univariate function of the Laplace variable.
    :type LaplaceExpr: sympy.Expr

    :param f: Frequency value (*float*), or a numpy array with frequency values
              (*float*).

    :return: dB Magnitude at the specified frequency, or list with dB magnitudes
             at the specified frequencies.

    :rtype: float, numpy.array
    """

    if type(f) == list:
        f = np.array(f)
    if ini.Hz == True:
        data = LaplaceExpr.xreplace({ini.Laplace: 2*sp.pi*sp.I*ini.frequency})
    else:
        data = LaplaceExpr.xreplace({ini.Laplace: sp.I*ini.frequency})
    if ini.frequency in list(data.atoms(sp.Symbol)):
        func = sp.lambdify(ini.frequency, 20*sp.log(sp.Abs(sp.N(data)), 10))
        return func(f)
    else:
        return([20*sp.log(sp.Abs(data))/sp.log(10) for i in range(len(f))])

def phaseFunc_f(LaplaceExpr, f):
    """
    Calculates the phase angle at the real frequency f (Fourier) from the
    univariate function 'LaplaceExpr' of the Laplace variable.

    If ini.Hz == true, the Laplace variable will be replaced with
    2*sp.pi*sp.I*ini.frequency.

    If ini.Hz == False, the Laplace variable will be replaced with
    sp.I*ini.frequency.

    :param LaplaceExpr: Univariate function of the Laplace variable.
    :type LaplaceExpr: sympy.Expr

    :param f: Frequency value (*float*), or a numpy array with frequency values
              (*float*).

    :return: Angle at the specified frequency, or list with angles at
             the specified frequencies.

    :rtype: float, numpy.array
    """

    if type(f) == list:
        f = np.array(f)
    if ini.Hz == True:
        data = LaplaceExpr.xreplace({ini.Laplace: 2*sp.pi*sp.I*ini.frequency})
    else:
        data = LaplaceExpr.xreplace({ini.Laplace: sp.I*ini.frequency})
    if ini.frequency in list(data.atoms(sp.Symbol)):
        func = sp.lambdify(ini.frequency, sp.N(data))
        phase = np.angle(func(f))
    elif data >= 0:
        phase = [0 for i in range(len(f))]
    elif data < 0:
        phase = [np.pi for i in range(len(f))]
    try:
        phase = np.unwrap(phase)
    except:
        pass
    if ini.Hz:
        phase = phase * 180/np.pi
    return phase

def delayFunc_f(LaplaceExpr, f, delta=10**(-ini.disp)):
    """
    Calculates the group delay at the real frequency f (Fourier) from the
    univariate function 'LaplaceExpr' of the Laplace variable.

    If ini.Hz == true, the Laplace variable will be replaced with
    2*sp.pi*sp.I*ini.frequency.

    If ini.Hz == False, the Laplace variable will be replaced with
    sp.I*ini.frequency.

    :param LaplaceExpr: Univariate function of the Laplace variable.
    :type LaplaceExpr: sympy.Expr

    :param f: Frequency value (*float*), or a numpy array with frequency values
              (*float*).

    :return: Group delay at the specified frequency, or list with group delays
             at the specified frequencies.

    :rtype: float, numpy.array
    """

    if type(f) == list:
        f = np.array(f)
    if ini.Hz == True:
        data = LaplaceExpr.xreplace({ini.Laplace: 2*sp.pi*sp.I*ini.frequency})
        func = sp.lambdify(ini.frequency, sp.N(data))
    else:
        data = LaplaceExpr.xreplace({ini.Laplace: sp.I*ini.frequency})
        func = sp.lambdify(ini.frequency, sp.N(data))
    if ini.frequency in list(data.atoms(sp.Symbol)):
        angle1 = np.angle(func(f))
        angle2 = np.angle(func(f*(1+delta)))
        try:
            angle1 = np.unwrap(angle1)
            angle2 = np.unwrap(angle2)
        except:
            pass
        delay  = (angle1 - angle2)/delta/f
        if ini.Hz == True:
            delay = delay/2/np.pi
        return delay
    else:
        return [0 for i in range(len(f))]

def mag_f(LaplaceExpr):
    """
    Returns the magnitude as a function of the real frequency f (Fourier)
    from the Laplace function 'LaplaceExpr'.

    If ini.Hz == true, the Laplace variable will be replaced with
    2*sp.pi*sp.I*ini.frequency.

    If ini.Hz == False, the Laplace variable will be replaced with
    sp.I*ini.frequency.

    :param LaplaceExpr: Univariate function of the Laplace variable.
    :type LaplaceExpr: sympy.Expr

    :param f: Frequency value (*float*), or a numpy array with frequency values
              (*float*).

    :return: Sympy expression representing the magnitude of the Fourier Transform.
    :rtype: sympy.Expr
    """

    if ini.Hz == True:
        data = LaplaceExpr.xreplace({ini.Laplace: 2*sp.pi*sp.I*ini.frequency})
    else:
        data = LaplaceExpr.xreplace({ini.Laplace: sp.I*ini.frequency})
    return sp.Abs(sp.N(data))

def phase_f(LaplaceExpr):
    """
    Calculates the magnitude as a function of the real frequency f (Fourier)
    from the Laplace function 'LaplaceExpr'.

    If ini.Hz == true, the Laplace variable will be replaced with
    2*sp.pi*sp.I*ini.frequency.

    If ini.Hz == False, the Laplace variable will be replaced with
    sp.I*ini.frequency.

    :param LaplaceExpr: Univariate function of the Laplace variable.
    :type LaplaceExpr: sympy.Expr

    :param f: Frequency value (*float*), or a numpy array with frequency values
              (*float*).

    :return: Sympy expression representing the phase of the Fourier Transform.
    :rtype: sympy.Expr
    """
    if ini.Hz == True:
        data = LaplaceExpr.xreplace({ini.Laplace: 2*sp.pi*sp.I*ini.frequency})
        return 180 * sp.arg(data) / sp.N(sp.pi)
    else:
        data = LaplaceExpr.xreplace({ini.Laplace: sp.I*ini.frequency})
        return sp.arg(sp.N(data))
    
def simplify(expr, method = 'fraction'):
    """
    Simplifies an expression. Simplification methods can be:
    
    #. *fraction*: The expression will be rewritten as a normal fraction,
       (also common fraction or simple fraction)
    #. *normalize*: The expression will be rewritten as a normal fraction,
       (also common fraction or simple fraction) in which the coefficient of
       the lowest order of ini.frequency or ini.laplace of the numerator and
       the denominatior are normalized to unity, while this rational is
       multiplied with the ratio of these coefficients.
    #. *factor*: The expression is rewritten as a product of factors.
    #. *expand*: The expression is expanded into a sum of normal fractions.
    
    :param: expr: sympy expression
    :type expr: sympy.Expr
    
    :return: simplified expression
    :rtype: sympy.Expr
    """
    try:
        if method == 'fraction':
            try:
                expr = sp.simplify(expr)
            except:
                numer, denom = expr.as_numer_denom()
                expr = numer/denom
        elif method == 'normalize':
            try:
                expr = sp.simplify(expr)
            except:
                numer, denom = expr.as_numer_denom()
                expr = numer/denom
            expr = normalizeLaplaceRational(expr)
        elif method == 'factor':
            expr = sp.factor(expr)
        elif method == 'expand':
            expr = sp.expand(expr)
    except:
        try:
            expr = sp.simplify(expr)
        except:
            pass
    return expr

def doCDSint(noiseResult, tau, f_min, f_max):
    """
    Returns the integral from ini.frequency = f_min to ini.frequency = f_max, 
    of a noise spectrum after multiplying it with (2*sin(pi*ini.frequency*tau))^2
    
    :param noiseResult: sympy expression of a noise density spectrum in V^2/Hz or A^2/Hz
    :type noiseResult: sympy.Expr, sympy.Symbol, int or float
    :param tau: Time between two samples
    :type tau: sympy.Expr, sympy.Symbol, int or float    
    :param f_min: Lower limit of the integral
    :type f_min: sympy.Expr, sympy.Symbol, int or float   
    :param f_max: Upper limit of the integral
    :type f_max: sympy.Expr, sympy.Symbol, int or float
    
    :return: integral of the spectrum from f_min to f_max after corelated double sampling
    :rtype: sympy.Expr, sympy.Symbol, int or float
    """
    _phi = sp.Symbol('_phi')
    noiseResult *= ((2*sp.sin(sp.pi*ini.frequency*tau)))**2
    noiseResult = noiseResult.subs(ini.frequency, _phi/tau/sp.pi)
    noiseResultCDSint = sp.integrate(noiseResult/sp.pi/tau, (_phi, f_min*tau*sp.pi, f_max*tau*sp.pi))
    return sp.simplify(noiseResultCDSint)

def doCDS(noiseResult, tau):
    """
    Returns noiseResult after multiplying it with (2*sin(pi*ini.frequency*tau))^2
    
    :param noiseResult: sympy expression of a noise density spectrum in V^2/Hz or A^2/Hz
    :type noiseResult: sympy.Expr, sympy.Symbol, int or float
    :param tau: Time between two samples
    :type tau: sympy.Expr, sympy.Symbol, int or float
    
    :return: noiseResult*(2*sin(pi*ini.frequency*tau))^2
    :rtype: sympy.Expr, sympy.Symbol, int or float
    """
    return noiseResult*((2*sp.sin(sp.pi*ini.frequency*tau)))**2

def routh(charPoly, eps):
    """
    Returns the Routh array of a polynomial of the Laplace variable (ini.Laplace).
    
    :param charPoly: Expression that can be written as a polynomial of the Laplace variable (ini.Laplace).
    :type charPoly:  sympy.Expr
    :param eps:      Symbolic variable used to indicate marginal stability. Use a symbol that is not present in *charPoly*.
    :type eps:       sympy.Symbol
    
    :return: Routh array
    :rtype:  sympy.Matrix
    
    :Example:

    >>> # ini.Laplace = sp.Symbol('s')
    >>> s, eps = sp.symbols('s, epsilon')
    >>> charPoly = s**4+2*s**3+(3+k)*s**2+(1+k)*s+(1+k)
    >>> M = routh(charPoly, eps)
    >>> print(M.col(0)) # Number of roots in the right half plane is equal to
    >>>                 # the number of sign changes in the first column of the
    >>>                 # Routh array
    Matrix([[1], [2], [k/2 + 5/2], [(k**2 + 2*k + 1)/(k + 5)], [k + 1]])
    """
    coeffs = sp.Poly(charPoly, ini.Laplace).all_coeffs()
    orders = len(coeffs)
    dim = int(np.ceil(orders/2))
    M  = [[0 for i in range(dim)] for i in range(orders)]
    M = sp.Matrix(M)
    # Fill the first two rows of the matrix
    for i in range(dim):
        # First row with even orders
        M[0,i] = coeffs[2*i]
        # Second row with odd orders 
        # Zero at the last position if the highest order is even
        if 2*i+1 < orders:
            M[1,i] = coeffs[2*i+1]
        else:
            M[1,i] = 0
    # Calculate all other coefficients of the matrix
    for i in range(2, orders):
        #print(M.row(i-1))
        if M.row(i-1) == sp.Matrix(sp.zeros(1, dim)):
            # Calculate the auxiliary polynomial
            for j in range(dim):
                M[i-1, j] = M[i-2,j]*(orders-i+1-2*j)
        for j in range(dim):
            if M[i-1,0] == 0:
                M[i-1, 0] = eps
            if j + 1 >= dim:
                subMatrix = sp.Matrix([[M[i-2,0], 0],[M[i-1, 0], 0]])
            else:
                subMatrix = sp.Matrix([[M[i-2,0], M[i-2, j+1]],[M[i-1, 0], M[i-1, j+1]]])
            M[i,j] = sp.simplify(-1/M[i-1,0]*subMatrix.det())
    return M

if __name__ == "__main__":
    s = ini.Laplace
    
    MNA = matrix([[5.0e-12*s + 0.01, 0, 0, -5.0e-12*s - 0.01, 0, 0, 0, 0, 1],
                  [0, 1.98e-11*s + 0.0001, -1.2e-11*s, -1.8e-12*s - 1.0e-5, 0, 0, 0, 0, 0],
                  [0, -1.2e-11*s, 2.8e-11*s + 0.001, 0, -1.0e-11*s - 0.001, 0, 0, -1, 0],
                  [-5.0e-12*s - 0.01, -1.8e-12*s - 1.0e-5, 0, 1.0068e-9*s + 0.01101, 0, 0, 1, 0, 0],
                  [0, 0, -1.0e-11*s - 0.001, 0, 1.0e-11*s + 0.001, 1, 0, 1, 0],
                  [0, 0, 0, 0, 1, 0, 0, 0, 0],
                  [0, 0, 0, 1, 0, 0, -1.0e-6*s, -3.1623e-11*s, 0],
                  [0, 0, -1, 0, 1, 0, -3.1623e-11*s, -1.0e-9*s, 0],
                  [2.048e-20*s**3 + 2.688e-11*s**2 + 0.0016*s + 1, 0, 0, 0, 0, 0, 0, 0, 0]])

    DET = MNA.determinant()
    t1=time()
    roots1 = numRoots(DET,s)
    t2=time()
    print(roots1, t2-t1)
    MOD = MNA.Cramer([0,0,0,1,0,-1,0,0,0],3)
    DET = MOD.determinant()
    roots2 = numRoots(DET,s)
    print(roots2)
    a = phase_f(DET)
    print(sp.N(a.subs(ini.frequency, 100)))
    loopgain_numer   = sp.sympify('-s*(1 + s/20)*(1 + s/40)/2')
    loopgain_denom   = sp.sympify('(s + 1)^2*(1 + s/4e3)*(1 + s/50e3)*(1 + s/1e6)')
    
    #loopgain_numer   = sp.sympify('-1e6')
    #loopgain_denom   = sp.sympify('(s)')
    loopgain         = loopgain_numer/loopgain_denom
    servo_info       = findServoBandwidth(loopgain)
    print(servo_info)
    
    
    k = sp.Symbol('k')
    charPoly = s**4+2*s**3+(3+k)*s**2+(1+k)*s+(1+k)
    #charPoly = 10 + 11*s +4*s**2 + 2*s**3 + 2*s**4 + s**5
    #charPoly = s**4-1
    #charPoly = s**5+s**4+2*s**3+2*s**2+s+1
    #roots = numRoots(charPoly, ini.Laplace)
    eps = sp.Symbol('epsilon')
    M= routh(charPoly, eps)
    #print(roots)
    print(M)